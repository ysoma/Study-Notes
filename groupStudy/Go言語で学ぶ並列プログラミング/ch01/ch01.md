# 読みながらの簡単なメモ

## 1章で扱う内容

- 並行プログラミングの紹介
- 並行実行による性能の向上
- プログラムのスケールアップ

### 1.1 並行処理について

本書では並行プログラミングの原則とパターンに焦点を当てる。
- 並行処理の概念
- Goが並行処理をモデル化する方法
- 競合状態について
- いくつかの並行プログラムで競合状態が発生する理由
- 主なやりかた「メモリ共有」と「メッセージパッシング」について
- 最後の数章では、並行処理パターン、デッドロック、スピンロックといった高度なトピックを説明する

### 1.2 並行的な世界とのやり取り

私たちは並行的な世界で生活している。

車の運転するとき、他の自動車、自転車、歩行者など複数の動作主体と影響し合う。料理中とかも同様。

もし２人の顧客が同時に注文し、在庫が１つしか残っていない場合、どうなる？

>***並行プログラミングとは、複数のタスクやプロセスが同時に実行され、相互利用可能なようにコードを書くこと***

### 1.3 スループットの向上

- スループット: コンピュータやネットワーク機器が単位時間あたりに処理できるデータ量のこと
- 水平スケーリング: 店員とレジの台数を増やす
- 垂直スケーリング: 店員の作業を超高速化させる

たとえプロセッサが１つでも並行プログラムには利点がある。待ち時間をうまく使えたり。

【実際に自分にあった例】  
お湯を沸かす  
コーヒーをハンドドリップする  
ここになって、先にパンを焼いておけばよかったと後悔  

【生じた疑問】  
私は翌日より、先にパンを焼き始めるようにプロセスを改善し、スループットが向上した。これは水平スケーリング？

### 1.4 応答性の向上

インタリーブシステム
>インターリーブまたはインターリービング（英: Interleaving）は計算機科学と電気通信において、データを何らかの領域（空間、時間、周波数など）で不連続な形で配置し、性能を向上させる技法を指す。(Wikipedia)

インタリーブシステムがなかったら、各タスクを１つずつ順番に実行しなければならない…どんだけ待つんだ…  
実際はOSがタスクを小分けにして高速に切り替えている。

### 1.5 Goで並行プログラミング

Goは並行プログラミングを学ぶのに適している。

#### 1.5.1 ゴルーチンの概要

Goにはゴルーチンってのがある。
 - ゴルーチンの特徴
   - 並列実行の基本単位のモデル化のためにある
   - 軽量な構造を使っている
   - カーネルレベルスレッドの集まりで実行される
   - Goのランタイムによって管理される、ユーザーレベルスレッドのシステムを提供する

正しい並行プログラムを書くことに集中し、Goのランタイムとハードウェアに並列処理を任せるべき。

- チャネル: ２つ以上のゴルーチンが互いにメッセージを渡し合えるもの

#### 1.5.2 CSPと基本操作による並行性のモデリング

並行処理のモデルには「CSPスタイル」と「古典的な方法」がある
本書ではまず「古典的な方法」から解説していく。

#### 1.5.3 独自の並行処理ツールの構築

本書では様々なツールの使い方も学ぶが、さらに一歩進んで、それらの仕組みを理解する為にゼロからの構築を試みる。ソートアルゴリズムを自前で実装するのと似たようなことだ。

### 1.6 性能のスケーリング

スケーラビリティには限界がある。日常生活を思い浮かべれば簡単に分かる話である。

#### 1.6.1 アムダールの法則
```
[定義]
システムの一部を最適化して得られる全体的な性能向上は、その改善された部分が実際に使われる時間の割合によって制限される
```
非並列部分のボトルネック化、プロセッサ数とスピードのグラフが印象的

#### 1.6.2  グスタフソンの法則

アムダールの法則に対する反論：余剰リソースをうまく配分したら線形にスケールするのでは

=> 問題によってどちらもそうと言える

### まとめと感想
- 実際のコードを早く見たい
- 「パフォーマンス」の話や「デッドロックの回避」等は金融システムへの応用可能性もありそうでモチベーションが沸いた。
- ハードを積めば速く動くという単純な話ではないということが分かった気がした